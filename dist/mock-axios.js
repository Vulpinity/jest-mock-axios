"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jestMockPromise = _interopRequireDefault(require("jest-mock-promise"));

var _Cancel = _interopRequireDefault(require("./cancel/Cancel"));

var _CancelToken = _interopRequireDefault(require("./cancel/CancelToken"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** a FIFO queue of pending request */
var _pending_requests = [];

var _newReq = function _newReq() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var url = config.url;
  var data = config.data;
  var promise = new _jestMockPromise["default"]();

  _pending_requests.push({
    config: config,
    data: data,
    promise: promise,
    url: url
  });

  return promise;
};

var _helperReq = function _helperReq(url, data, config) {
  var conf = data && config ? config : {};
  return _newReq(_objectSpread({}, conf, {
    data: data,
    url: url
  }));
};

var MockAxios = jest.fn(_newReq); // mocking Axios methods

MockAxios.get = jest.fn(_helperReq);
MockAxios.post = jest.fn(_helperReq);
MockAxios.put = jest.fn(_helperReq);
MockAxios.patch = jest.fn(_helperReq);
MockAxios["delete"] = jest.fn(_helperReq);
MockAxios.request = jest.fn(_newReq);
MockAxios.all = jest.fn(function (values) {
  return Promise.all(values);
});
MockAxios.head = jest.fn(_helperReq);
MockAxios.options = jest.fn(_helperReq);
MockAxios.create = jest.fn(function () {
  return MockAxios;
});
MockAxios.interceptors = {
  request: {
    use: jest.fn()
  },
  response: {
    use: jest.fn()
  }
};
MockAxios.defaults = {
  headers: {
    common: []
  }
};

MockAxios.popPromise = function (promise) {
  if (promise) {
    // remove the promise from pending queue
    for (var ix = 0; ix < _pending_requests.length; ix++) {
      var req = _pending_requests[ix];

      if (req.promise === promise) {
        _pending_requests.splice(ix, 1);

        return req.promise;
      }
    }
  } else {
    // take the oldest promise
    var _req = _pending_requests.shift();

    return _req ? _req.promise : void 0;
  }
};

MockAxios.popRequest = function (request) {
  if (request) {
    var ix = _pending_requests.indexOf(request);

    if (ix === -1) {
      return void 0;
    }

    _pending_requests.splice(ix, 1);

    return request;
  } else {
    return _pending_requests.shift();
  }
};
/**
 * Removes an item form the queue, based on it's type
 * @param queueItem
 */


var popQueueItem = function popQueueItem() {
  var queueItem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  // first let's pretend the param is a queue item
  var request = MockAxios.popRequest(queueItem);

  if (request) {
    // IF the request was found
    // > set the promise
    return request.promise;
  } else {
    // ELSE maybe the `queueItem` is a promise (legacy mode)
    return MockAxios.popPromise(queueItem);
  }
};

MockAxios.mockResponse = function (response) {
  var queueItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // replacing missing data with default values
  response = Object.assign({
    config: {},
    data: {},
    headers: {},
    status: 200,
    statusText: "OK"
  }, response);
  var promise = popQueueItem(queueItem);

  if (!promise && !silentMode) {
    throw new Error("No request to respond to!");
  } else if (!promise) {
    return;
  } // resolving the Promise with the given response data


  promise.resolve(response);
};

MockAxios.mockError = function () {
  var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var queueItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var promise = popQueueItem(queueItem);

  if (!promise && !silentMode) {
    throw new Error("No request to respond to!");
  } else if (!promise) {
    return;
  } // resolving the Promise with the given response data


  promise.reject(Object.assign({}, error));
};

MockAxios.lastReqGet = function () {
  return _pending_requests[_pending_requests.length - 1];
};

MockAxios.lastPromiseGet = function () {
  var req = MockAxios.lastReqGet();
  return req ? req.promise : void 0;
};

MockAxios.getReqByUrl = function (url) {
  return _pending_requests.slice().reverse() // reverse cloned array to return most recent req
  .find(function (x) {
    return x.url === url;
  });
};

MockAxios.reset = function () {
  // remove all the requests
  _pending_requests.splice(0, _pending_requests.length); // resets all information stored in the mockFn.mock.calls and mockFn.mock.instances arrays


  MockAxios.get.mockClear();
  MockAxios.post.mockClear();
  MockAxios.put.mockClear();
  MockAxios.patch.mockClear();
  MockAxios["delete"].mockClear();
  MockAxios.head.mockClear();
  MockAxios.options.mockClear();
  MockAxios.request.mockClear();
  MockAxios.all.mockClear();
};

MockAxios.Cancel = _Cancel["default"];
MockAxios.CancelToken = _CancelToken["default"];

MockAxios.isCancel = function (u) {
  return !!(u && u.__CANCEL__);
}; // this is a singleton object


var _default = MockAxios;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi9tb2NrLWF4aW9zLnRzIl0sIm5hbWVzIjpbIl9wZW5kaW5nX3JlcXVlc3RzIiwiX25ld1JlcSIsImNvbmZpZyIsInVybCIsImRhdGEiLCJwcm9taXNlIiwiU3luY1Byb21pc2UiLCJwdXNoIiwiX2hlbHBlclJlcSIsImNvbmYiLCJNb2NrQXhpb3MiLCJqZXN0IiwiZm4iLCJnZXQiLCJwb3N0IiwicHV0IiwicGF0Y2giLCJyZXF1ZXN0IiwiYWxsIiwidmFsdWVzIiwiUHJvbWlzZSIsImhlYWQiLCJvcHRpb25zIiwiY3JlYXRlIiwiaW50ZXJjZXB0b3JzIiwidXNlIiwicmVzcG9uc2UiLCJkZWZhdWx0cyIsImhlYWRlcnMiLCJjb21tb24iLCJwb3BQcm9taXNlIiwiaXgiLCJsZW5ndGgiLCJyZXEiLCJzcGxpY2UiLCJzaGlmdCIsInBvcFJlcXVlc3QiLCJpbmRleE9mIiwicG9wUXVldWVJdGVtIiwicXVldWVJdGVtIiwibW9ja1Jlc3BvbnNlIiwic2lsZW50TW9kZSIsIk9iamVjdCIsImFzc2lnbiIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJFcnJvciIsInJlc29sdmUiLCJtb2NrRXJyb3IiLCJlcnJvciIsInJlamVjdCIsImxhc3RSZXFHZXQiLCJsYXN0UHJvbWlzZUdldCIsImdldFJlcUJ5VXJsIiwic2xpY2UiLCJyZXZlcnNlIiwiZmluZCIsIngiLCJyZXNldCIsIm1vY2tDbGVhciIsIkNhbmNlbCIsIkNhbmNlbFRva2VuIiwiaXNDYW5jZWwiLCJ1IiwiX19DQU5DRUxfXyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVFBOztBQUNBOztBQUNBOzs7Ozs7OztBQU9BO0FBQ0EsSUFBTUEsaUJBQXVDLEdBQUcsRUFBaEQ7O0FBRUEsSUFBTUMsT0FBc0MsR0FBRyxTQUF6Q0EsT0FBeUMsR0FBc0I7QUFBQSxNQUFyQkMsTUFBcUIsdUVBQVAsRUFBTztBQUNqRSxNQUFNQyxHQUFXLEdBQUdELE1BQU0sQ0FBQ0MsR0FBM0I7QUFDQSxNQUFNQyxJQUFTLEdB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LENBQUNPLE9BQVYsQ0FBa0IwQyxTQUFsQjtBQUNBakQsRUFBQUEsU0FBUyxDQUFDUSxHQUFWLENBQWN5QyxTQUFkO0FBQ0gsQ0FkRDs7QUFnQkFqRCxTQUFTLENBQUNrRCxNQUFWLEdBQW1CQSxrQkFBbkI7QUFDQWxELFNBQVMsQ0FBQ21ELFdBQVYsR0FBd0JBLHVCQUF4Qjs7QUFDQW5ELFNBQVMsQ0FBQ29ELFFBQVYsR0FBcUIsVUFBQ0MsQ0FBRCxFQUFvQjtBQUNyQyxTQUFPLENBQUMsRUFBRUEsQ0FBQyxJQUFJQSxDQUFDLENBQUNDLFVBQVQsQ0FBUjtBQUNILENBRkQsQyxDQUlBOzs7ZUFDZXRELFMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFR5cGVTY3JpcHQgdmVyc2lvbiBvZiBBeGlvcyBtb2NrIGZvciB1bml0IHRlc3Rpbmcgd2l0aCBbSmVzdF0oaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8pLlxuICogVGhpcyBmaWxlIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3R1eDQvMzYwMDZhMTg1OTMyM2Y3NzlhYjBcbiAqXG4gKiBAYXV0aG9yICAga25lZS1jb2xhIDxuaWtvbGEuZGVyZXppY0BnbWFpbC5jb20+XG4gKiBAbGljZW5zZSAgQGxpY2Vuc2UgTUlUIExpY2Vuc2UsIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuaW1wb3J0IFN5bmNQcm9taXNlIGZyb20gXCJqZXN0LW1vY2stcHJvbWlzZVwiO1xuaW1wb3J0IENhbmNlbCBmcm9tIFwiLi9jYW5jZWwvQ2FuY2VsXCI7XG5pbXBvcnQgQ2FuY2VsVG9rZW4gZnJvbSBcIi4vY2FuY2VsL0NhbmNlbFRva2VuXCI7XG5pbXBvcnQge1xuICAgIEF4aW9zTW9ja1F1ZXVlSXRlbSxcbiAgICBBeGlvc01vY2tUeXBlLFxuICAgIEh0dHBSZXNwb25zZSxcbn0gZnJvbSBcIi4vbW9jay1heGlvcy10eXBlc1wiO1xuXG4vKiogYSBGSUZPIHF1ZXVlIG9mIHBlbmRpbmcgcmVxdWVzdCAqL1xuY29uc3QgX3BlbmRpbmdfcmVxdWVzdHM6IEF4aW9zTW9ja1F1ZXVlSXRlbVtdID0gW107XG5cbmNvbnN0IF9uZXdSZXE6IChjb25maWc/OiBhbnkpID0+IFN5bmNQcm9taXNlID0gKGNvbmZpZzogYW55ID0ge30pID0+IHtcbiAgICBjb25zdCB1cmw6IHN0cmluZyA9IGNvbmZpZy51cmw7XG4gICAgY29uc3QgZGF0YTogYW55ID0gY29uZmlnLmRhdGE7XG4gICAgY29uc3QgcHJvbWlzZTogU3luY1Byb21pc2UgPSBuZXcgU3luY1Byb21pc2UoKTtcbiAgICBfcGVuZGluZ19yZXF1ZXN0cy5wdXNoKHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBkYXRhLFxuICAgICAgICBwcm9taXNlLFxuICAgICAgICB1cmwsXG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5jb25zdCBfaGVscGVyUmVxID0gKHVybDogc3RyaW5nLCBkYXRhPzogYW55LCBjb25maWc/OiBhbnkpID0+IHtcbiAgICBjb25zdCBjb25mID0gZGF0YSAmJiBjb25maWcgPyBjb25maWcgOiB7fTtcbiAgICByZXR1cm4gX25ld1JlcSh7XG4gICAgICAgIC4uLmNvbmYsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHVybCxcbiAgICB9KTtcbn07XG5cbmNvbnN0IE1vY2tBeGlvczogQXhpb3NNb2NrVHlwZSA9IChqZXN0LmZuKF9uZXdSZXEpIGFzIHVua25vd24pIGFzIEF4aW9zTW9ja1R5cGU7XG5cbi8vIG1vY2tpbmcgQXhpb3MgbWV0aG9kc1xuTW9ja0F4aW9zLmdldCA9IGplc3QuZm4oX2hlbHBlclJlcSk7XG5Nb2NrQXhpb3MucG9zdCA9IGplc3QuZm4oX2hlbHBlclJlcSk7XG5Nb2NrQXhpb3MucHV0ID0gamVzdC5mbihfaGVscGVyUmVxKTtcbk1vY2tBeGlvcy5wYXRjaCA9IGplc3QuZm4oX2hlbHBlclJlcSk7XG5Nb2NrQXhpb3MuZGVsZXRlID0gamVzdC5mbihfaGVscGVyUmVxKTtcbk1vY2tBeGlvcy5yZXF1ZXN0ID0gamVzdC5mbihfbmV3UmVxKTtcbk1vY2tBeGlvcy5hbGwgPSBqZXN0LmZuKCh2YWx1ZXMpID0+IFByb21pc2UuYWxsKHZhbHVlcykpO1xuTW9ja0F4aW9zLmhlYWQgPSBqZXN0LmZuKF9oZWxwZXJSZXEpO1xuTW9ja0F4aW9zLm9wdGlvbnMgPSBqZXN0LmZuKF9oZWxwZXJSZXEpO1xuTW9ja0F4aW9zLmNyZWF0ZSA9IGplc3QuZm4oKCkgPT4gTW9ja0F4aW9zKTtcblxuTW9ja0F4aW9zLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiB7XG4gICAgICAgIHVzZTogamVzdC5mbigpLFxuICAgIH0sXG4gICAgcmVzcG9uc2U6IHtcbiAgICAgICAgdXNlOiBqZXN0LmZuKCksXG4gICAgfSxcbn07XG5cbk1vY2tBeGlvcy5kZWZhdWx0cyA9IHtcbiAgICBoZWFkZXJzOiB7XG4gICAgICAgIGNvbW1vbjogW10sXG4gICAgfSxcbn07XG5cbk1vY2tBeGlvcy5wb3BQcm9taXNlID0gKHByb21pc2U/OiBTeW5jUHJvbWlzZSkgPT4ge1xuICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgcHJvbWlzZSBmcm9tIHBlbmRpbmcgcXVldWVcbiAgICAgICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IF9wZW5kaW5nX3JlcXVlc3RzLmxlbmd0aDsgaXgrKykge1xuICAgICAgICAgICAgY29uc3QgcmVxOiBBeGlvc01vY2tRdWV1ZUl0ZW0gPSBfcGVuZGluZ19yZXF1ZXN0c1tpeF07XG5cbiAgICAgICAgICAgIGlmIChyZXEucHJvbWlzZSA9PT0gcHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIF9wZW5kaW5nX3JlcXVlc3RzLnNwbGljZShpeCwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGFrZSB0aGUgb2xkZXN0IHByb21pc2VcbiAgICAgICAgY29uc3QgcmVxOiBBeGlvc01vY2tRdWV1ZUl0ZW0gPSBfcGVuZGluZ19yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gcmVxID8gcmVxLnByb21pc2UgOiB2b2lkIDA7XG4gICAgfVxufTtcblxuTW9ja0F4aW9zLnBvcFJlcXVlc3QgPSAocmVxdWVzdD86IEF4aW9zTW9ja1F1ZXVlSXRlbSkgPT4ge1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGl4ID0gX3BlbmRpbmdfcmVxdWVzdHMuaW5kZXhPZihyZXF1ZXN0KTtcbiAgICAgICAgaWYgKGl4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wZW5kaW5nX3JlcXVlc3RzLnNwbGljZShpeCwgMSk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfcGVuZGluZ19yZXF1ZXN0cy5zaGlmdCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpdGVtIGZvcm0gdGhlIHF1ZXVlLCBiYXNlZCBvbiBpdCdzIHR5cGVcbiAqIEBwYXJhbSBxdWV1ZUl0ZW1cbiAqL1xuY29uc3QgcG9wUXVldWVJdGVtID0gKHF1ZXVlSXRlbTogU3luY1Byb21pc2UgfCBBeGlvc01vY2tRdWV1ZUl0ZW0gPSBudWxsKSA9PiB7XG4gICAgLy8gZmlyc3QgbGV0J3MgcHJldGVuZCB0aGUgcGFyYW0gaXMgYSBxdWV1ZSBpdGVtXG4gICAgY29uc3QgcmVxdWVzdDogQXhpb3NNb2NrUXVldWVJdGVtID0gTW9ja0F4aW9zLnBvcFJlcXVlc3QoXG4gICAgICAgIHF1ZXVlSXRlbSBhcyBBeGlvc01vY2tRdWV1ZUl0ZW0sXG4gICAgKTtcblxuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgIC8vIElGIHRoZSByZXF1ZXN0IHdhcyBmb3VuZFxuICAgICAgICAvLyA+IHNldCB0aGUgcHJvbWlzZVxuICAgICAgICByZXR1cm4gcmVxdWVzdC5wcm9taXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVMU0UgbWF5YmUgdGhlIGBxdWV1ZUl0ZW1gIGlzIGEgcHJvbWlzZSAobGVnYWN5IG1vZGUpXG4gICAgICAgIHJldHVybiBNb2NrQXhpb3MucG9wUHJvbWlzZShxdWV1ZUl0ZW0gYXMgU3luY1Byb21pc2UpO1xuICAgIH1cbn07XG5cbk1vY2tBeGlvcy5tb2NrUmVzcG9uc2UgPSAoXG4gICAgcmVzcG9uc2U/OiBIdHRwUmVzcG9uc2UsXG4gICAgcXVldWVJdGVtOiBTeW5jUHJvbWlzZSB8IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IG51bGwsXG4gICAgc2lsZW50TW9kZTogYm9vbGVhbiA9IGZhbHNlLFxuKTogdm9pZCA9PiB7XG4gICAgLy8gcmVwbGFjaW5nIG1pc3NpbmcgZGF0YSB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgcmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogXCJPS1wiLFxuICAgICAgICB9LFxuICAgICAgICByZXNwb25zZSxcbiAgICApO1xuXG4gICAgY29uc3QgcHJvbWlzZSA9IHBvcFF1ZXVlSXRlbShxdWV1ZUl0ZW0pO1xuXG4gICAgaWYgKCFwcm9taXNlICYmICFzaWxlbnRNb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlcXVlc3QgdG8gcmVzcG9uZCB0byFcIik7XG4gICAgfSBlbHNlIGlmICghcHJvbWlzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2aW5nIHRoZSBQcm9taXNlIHdpdGggdGhlIGdpdmVuIHJlc3BvbnNlIGRhdGFcbiAgICBwcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xufTtcblxuTW9ja0F4aW9zLm1vY2tFcnJvciA9IChcbiAgICBlcnJvcjogYW55ID0ge30sXG4gICAgcXVldWVJdGVtOiBTeW5jUHJvbWlzZSB8IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IG51bGwsXG4gICAgc2lsZW50TW9kZTogYm9vbGVhbiA9IGZhbHNlLFxuKSA9PiB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHBvcFF1ZXVlSXRlbShxdWV1ZUl0ZW0pO1xuXG4gICAgaWYgKCFwcm9taXNlICYmICFzaWxlbnRNb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlcXVlc3QgdG8gcmVzcG9uZCB0byFcIik7XG4gICAgfSBlbHNlIGlmICghcHJvbWlzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2aW5nIHRoZSBQcm9taXNlIHdpdGggdGhlIGdpdmVuIHJlc3BvbnNlIGRhdGFcbiAgICBwcm9taXNlLnJlamVjdChPYmplY3QuYXNzaWduKHt9LCBlcnJvcikpO1xufTtcblxuTW9ja0F4aW9zLmxhc3RSZXFHZXQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIF9wZW5kaW5nX3JlcXVlc3RzW19wZW5kaW5nX3JlcXVlc3RzLmxlbmd0aCAtIDFdO1xufTtcblxuTW9ja0F4aW9zLmxhc3RQcm9taXNlR2V0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHJlcSA9IE1vY2tBeGlvcy5sYXN0UmVxR2V0KCk7XG4gICAgcmV0dXJuIHJlcSA/IHJlcS5wcm9taXNlIDogdm9pZCAwO1xufTtcblxuTW9ja0F4aW9zLmdldFJlcUJ5VXJsID0gKHVybDogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIF9wZW5kaW5nX3JlcXVlc3RzXG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5yZXZlcnNlKCkgLy8gcmV2ZXJzZSBjbG9uZWQgYXJyYXkgdG8gcmV0dXJuIG1vc3QgcmVjZW50IHJlcVxuICAgICAgICAuZmluZCgoeDogQXhpb3NNb2NrUXVldWVJdGVtKSA9PiB4LnVybCA9PT0gdXJsKTtcbn07XG5cbk1vY2tBeGlvcy5yZXNldCA9ICgpID0+IHtcbiAgICAvLyByZW1vdmUgYWxsIHRoZSByZXF1ZXN0c1xuICAgIF9wZW5kaW5nX3JlcXVlc3RzLnNwbGljZSgwLCBfcGVuZGluZ19yZXF1ZXN0cy5sZW5ndGgpO1xuXG4gICAgLy8gcmVzZXRzIGFsbCBpbmZvcm1hdGlvbiBzdG9yZWQgaW4gdGhlIG1vY2tGbi5tb2NrLmNhbGxzIGFuZCBtb2NrRm4ubW9jay5pbnN0YW5jZXMgYXJyYXlzXG4gICAgTW9ja0F4aW9zLmdldC5tb2NrQ2xlYXIoKTtcbiAgICBNb2NrQXhpb3MucG9zdC5tb2NrQ2xlYXIoKTtcbiAgICBNb2NrQXhpb3MucHV0Lm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5wYXRjaC5tb2NrQ2xlYXIoKTtcbiAgICBNb2NrQXhpb3MuZGVsZXRlLm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5oZWFkLm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5vcHRpb25zLm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5yZXF1ZXN0Lm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5hbGwubW9ja0NsZWFyKCk7XG59O1xuXG5Nb2NrQXhpb3MuQ2FuY2VsID0gQ2FuY2VsO1xuTW9ja0F4aW9zLkNhbmNlbFRva2VuID0gQ2FuY2VsVG9rZW47XG5Nb2NrQXhpb3MuaXNDYW5jZWwgPSAodSk6IHUgaXMgQ2FuY2VsID0+IHtcbiAgICByZXR1cm4gISEodSAmJiB1Ll9fQ0FOQ0VMX18pO1xufTtcblxuLy8gdGhpcyBpcyBhIHNpbmdsZXRvbiBvYmplY3RcbmV4cG9ydCBkZWZhdWx0IE1vY2tBeGlvcztcbiJdfQ==